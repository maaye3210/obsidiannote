# 自我介绍

面试官你好，我叫马阿业，来自哈尔滨工业大学，本科专业不是计算机方向的，但是由于个人兴趣的原因我自学了前端技术和计算机基础，并且以后想往这个方向发展。

计算机专业的几个核心课程我也自学过，像前端比较重要的计算机网络，数据结构，设计模式等等，也了解数据库，编译原理等课程并且也在持续学习。

在前端技术方面，我现在已经学习了主要的知识和语言以及前端工程化的技能，两个目前最主流的框架react和vue也学过，主要是Vue3、React18和Typescript。了解过react和vue的源码，对vue了解的比较深入，之前自己手写实现过一个简化版的vue，对其响应式原理以及运行时有比较详细的了解。并且都完成过项目：用Vue做了一个仿QQ音乐的项目，并且使用jenkins做了自动构建和部署，现在部署在腾讯云服务器上，用React做的一个后台管理和可视化项目。

今年六月到九月在北京魔门塔实习，从事的工作也是前端开发。主要负责一个叫做路线管理平台的后台管理系统的开发和维护，除了后台管理系统主要的增删改查和数据可视化的功能，还实现了用户权限管理，国际化，线上多环境支持，报错处理，以及用户体验优化和性能优化，同时对接了公司另一个地图可视化平台，在地图可视化平台上进行对路线数据的操作并实时同步到路线管理平台等等。实习期间最大的收获是学习了React和它的原理，设计模式，提升了自己的代码能力，还有就是熟悉了开发，上线，维护等等工作流程，以及用git进行协作开发等等。

# mini-vue项目亮点

## 项目背景

在学习vue响应式原理的时候，找到过一篇比较好的文章，于是就按照文章的思路自己实现了vue3的响应式原理。但是后来还是不理解vue3的工作原理，也就是如何将这种响应式应用在dom操作上的，于是又找了一些文章，了解了vue其他部分的原理，也就是vue的**编译**和**运行时**模块。了解之后就开始着手尝试，先是实现了它的运行时，也就是源码中`runtime-core`和`runtime-dom`部分，然后又写了一些它的编译模块的代码，也就是对应源码的`compiler-core`部分，不过这部分只完成了最基础的元素、变量和文字节点的编译。其他的部分暂时还没有做。

```
                           +---------------------+
                           |                     |
                           |  @vue/compiler-sfc  |
                           |                     |
                           +-----+--------+------+
                                 |        |
                                 v        v
             +---------------------+    +----------------------+
             |                     |    |                      |
     +------>|  @vue/compiler-dom  +--->|  @vue/compiler-core  |
     |       |                     |    |                      |
+----+----+  +---------------------+    +----------------------+
|         |
|   vue   |
|         |
+----+----+  +------------------+  +-------------------+  +-----------------+
     |       |                  |  |                   |  |                 |
     +------>| @vue/runtime-dom +->| @vue/runtime-core +->| @vue/reactivity |
             |                  |  |                   |  |                 |
             +------------------+  +-------------------+  +-----------------+
```



## 项目成果

项目跟vue一样，使用了`monorepo`架构，不过只完成了`reactivity`、`runtime-core`、`runtime-dom`还有`compiler-core`部分。

> monorepo 优点：简化依赖管理，共享所有的依赖。团队协作的时候代码风格和质量更加统一，当某个子项或者依赖发生改变时，会迫使其他子项跟着改变。
>
> monorepo 缺点：代码管理起来会更复杂，如果规划的不好的话，子项目之间耦合严重，新人理解起来会非常困难。

#### `reactivity`部分

实现了`reactive`、`effect`这两个基础函数，也是最核心的部分。另外还实现了一些额外功能，比如`readonly`、`shallowreadonly`、`ref`，还有一些工具函数`unref`、`proxyRefs`、`isReactive`，`isProxy`等等，还有实现了`computed`功能，当依赖项发生改变时，重新调用getter才会执行重新计算并缓存。

> `reactive`、`effect`：主要功能和vue一样：`reactive`就是用`Proxy`代理数据；`effect`就是创建一个`ReactiveEffect`对象，这个对象储存着依赖函数。
>
> 调用effect的时候会首先把自己的`ReactiveEffect`对象挂载到一个全局的位置，然后执行依赖函数，依赖函数中遇到`Proxy`代理对象触发get的时候，就会出发tracker函数，将全局变量挂载的收集起来。收集的方式就是用一个map存储代理对象的目标对象，用另一个map储存目标对象的每个属性和依赖这个属性的Set对象，Set对象中储存的就是`ReactiveEffect`对象。当触发依赖时，就会触发trigger函数调用`ReactiveEffect`的run方法重新执行依赖函数。
>
> 至此，响应式最核心的部分就完成了。
>
> 可以看出，实际上这部分是一个可复用性很强，独立性很强的代码。

> **亮点：**用了jest做单元测试，提高了开发效率和，减少了bug，每次有比较大的改动都会重新运行所有测试，有bug总能提前发现，所以开发周期短了很多

#### `runtime-core`部分

runtime-core基于reactivity，是vue实现dom操作的最重要部分，而**vue的runtime-dom**做的事情其实只是提供一系列用于操作浏览器页面的接口而已，在vue中，我们甚至可以直接调用**vue的runtime-core**提供的创建渲染器的接口`createRender`，自定义渲染功能，比如可以在canvas上实现功能。

在这个部分我主要完成了**挂载和更新组件，元素，文本和Fragment**这四类节点，并且在更新数组类型的子节点的时候使用的`双端diff算法`提高效率。其中最重要的组件类型，还实现了`插槽`、`自定义事件`、`provide`和`inject`的组合，另外还有组件实例上的几个重要的变量，比如说`$el`，`$props`，`$slots`。还有实现了和vue3一样的异步渲染功能，因此也提供了对应的`nextTick`

> ##### 实现挂载和更新组件，元素，文本和Fragment基本流程：
>
> **挂载**：这个过程主要就是递归，挂载的时候我们主要就是拿到一个根节点虚拟dom，然后从根节点开始递归的遍历子节点（深度优先），根据不同的节点类型，调用不同的process函数，第一次都是mount，递归结束后就能把所有的节点插入根元素了。
>
> **组件的挂载**：挂载过程中最重要的就是组件的处理了。
>
> 1. 首先要创建一个组件实例`instance`，用来挂载上组件的各种信息。更新的时候，也是靠这些信息来更新。
> 2. 然后调用组件的setup函数，把setup的返回值挂在instance实例上，还有初始化的props，slot等等。
> 3. 调用render函数，获得组件的虚拟子节点树，也挂载在`instance`组件实例上，更新的时候要用到。
> 4. 创建好instance实例之后还有一个重要的过程，就是创建组件的子树，为了实现响应式，我们需要**用reactivity模块的effect包裹我们创建子树和更新子树的逻辑，并且用闭包保护之前的组件的instance实例**，方便再次调用的时候访问。reactivity和runtime-core结合的地方就体现在这里。
>
> **更新**：当某个响应式数据更新后，就会触发trigger函数，重新执行依赖函数，也就是上面说的“**创建子树和更新子树的逻辑**”，因为我们是更新子树，所以已经有了instance实例，接下来只需要递归的对比新老虚拟节点，对变化的节点做出更新就好。然后用diff算法进行优化。

> ##### 亮点：
>
> 1. 代理模式：为了能使我们在调用渲染函数的时候，可以通过this访问到`props`，`setup返回值上的各种属性`，还有`$el`,`$slot`等等数据，**这里使用了代理模式，一是避免instance实例上的属性太多，另外一个是方便扩展**，用一个代理来作为对外的接口，调用render函数的时候把this指向这个代理对象，然后就能实现了对这些数据的访问。
> 2. 支持jsx：调用组件的setup函数，正常情况下是把返回值挂载在setupState上，但是如果返回值直接是一个函数的话就挂在render上。
> 3. 实现多态的runtime-core：在runtime-core中没有任何真正操作dom的代码，因为这并不是它的职责所在，我希望它的职责只是派发任务，为了分离出这部分代码，我把操作dom的代码被提取出来，作为选项传入，在runtime-dom中实现。所以也可以写一个runtime-canvas，让vue在canvas上渲染。
> 4. 实现异步渲染和`nextTick`：为之前的reactivity模块增加了两个功能，一是让effect返回`ReactiveEffect`的run方法，二是可以自定义依赖变化时执行的函数，首先保存一下`ReactiveEffect`的run方法，自定义回调函数的时候把这个对象推入一个异步任务队列中就可以了。而`nextTick`使用promise实现，会将传入的函数延迟到其他异步任务执行完成之后进行（由调用顺序决定）

#### `compiler-core`部分

`compiler-core`部分实现的功能就是：先将template字符串转换成抽象语法树，再将抽象语法树经过一系列的处理转换为**可以执行的一段返回一个render函数的代码**

> ##### template->抽象语法树————parse
>
> 实现方式是通过一个有限元状态机，不断的读取字符串，然后将他们转化成一个储存着最基本的HTML节点信息的树形结构。状态机如下图。
>
> ![](C:\Users\Administrator\Desktop\面试准备\parse流程图.jpg)

> ##### 抽象语法树Transform
>
> 深度优先遍历ast语法树上的节点，对节点进行处理，方便后面生成代码
>
> **亮点：**使用了`插件体系`，将代码执行的过程中**不变的流程**和**变化的处理方式**分离，使得程序具有**可扩展性**

> ##### 抽象语法树->可执行代码
>
> 这个过程也是遍历抽象语法树，然后根据语法树的结构生成一段render函数
>
> **亮点：**这段代码是需要被用在runtime-core里的，但是由于我用的monorepo架构，这个模块不应该让runtime-core直接导入，Vue的作者在贡献文档里特地指明了这一点，所以为了分离出这个模块，必须**先让最顶层的Vue引用，然后注册到runtime-core中，实现runtime-core和compiler-core的解耦**



# music项目亮点

## 项目介绍

我在简历上挂了在线地址，面试官您可以点进去看一下。这个项目模仿QQ音乐客户端UI，用Vue3实现了一个网页版的音乐播放器，后端的话采用的是开源的网易云音乐API。功能也是模仿QQ音乐客户端，实现了它的主要的功能，像音乐播放与控件、歌单、电台、视频播放、滚动歌词、播放列表、登录、搜索、以及用户账户信息的拉取和展示等等。

## 项目成果

现在已经成功上线了，我在简历上挂了在线地址，面试官您可以点进去看一下。而且功能已经比较完善了，除了下载功能，最重要的骨架已经完成，还剩下一些比较细节的功能还不太完善。等我把下载部分的功能完成之后就会慢慢完善。最近刚刚引入了一个动画库，打算给我的图标加一些动效。

## 项目亮点

1. 我使用的技术栈很新，比如`tailwindcss`，`vite`，`Pinia`，`TypeScript`。
2. 界面的还原度很高，几乎和原版的QQ音乐一模一样，并且因为使用了tailwindcss，也实现了响应式，各种大小的窗口视觉效果都还不错。
3. 支持两种播放模式，一个是电台播放模式，一个是音乐播放模式，而且还支持不同的播放顺序。
4. 实现了全屏播放功能，还支持滚动歌词，并且这个滚动歌词的实现方式我自认为比较高效。
5. 支持搜索功能和推荐搜索功能，并且同时可以显示和区分搜索到的所有不同类型的信息，您也可以试一试。
6. 实现了登录功能，登录后可以查看视频和自己的收藏的歌曲。

## 项目难点

> 我觉的最难的部分是播放器的控制逻辑，因为它有很多模式，要实现电台模式，和音乐模式的切换，循环顺序的切换，还要控制播放器的进度，维护播放列表，进度条的拖动等等。一开始功能比较少的时候还算可以，但是后来功能完善了起来，相关的代码就越来越难以维护。于是后来我结合了状态模式的思想，一是区分电台状态和音乐状态，二是区分循环状态，会根据不同的状态，走不同的逻辑，代码梳理下来之后就清晰多了，维护起来也方便很多。
>
> 滚动歌词部分采用的是双向链表。为了优化
>
> 另外还有一个比较有意思的部分是滚动歌词部分，当时一开始我做这个项目的时候并没有考虑到这个滚动歌词的细节，所以后来添加这个功能就遇到了很多麻烦，主要的问题是，超时定时器不能连续使用，这样的话它的误差会积累起来然后越来越大；我搜索到的解决方法都差不多，就是用循环定时器，大概每50毫秒执行一次，然后每次都去检查当前歌曲播放时间和歌词位置是不是匹配，不匹配的话就去下一条。但是首先这种方法效率很低，每50ms执行一次都会有一点卡顿，一直执行同一个无用的功能很浪费，有的时候可能10秒才换一句歌词但它却执行了2000次。
>
> 首先我在全局只有一个定时器，一秒触发一次，用来获取播放器的当前播放位置更新歌曲的进度。而且开发的过程中有很多地方都会用到这个定时器。
>
> 然后我想到了两种解决方案，一个是每次换歌词的时候都检查一下播放器的当前时间和下一句歌词的开始时间，用这个时间作为超时时间。确实可以实现，但是为了使用这个功能我之前写的很多代码都要跟他同步，因为它是一个跟原来的定时器没有任何关系的定时器。
>
> 于是我想了另一个比较创新的解决办法——用超时定时器和全局定时器结合，我定义了一个类，实现的功能是，传入一个时间轴上一系列时间节点组成的数组，内部使用超时定时器来实现在规定的时间点调用回调，上面有一个方法，用来设置时间到时间轴轴到规定的位置，每次重置时间轴，误差都会重置，因此不会导致误差越来越大。因此只需要再加上暂停和开始方法，在外部额外处理一下暂停和开始，然后在全局定时器的回调函数里调用一下设置时间方法就可以实现功能了。
>
> 我觉得这个功能还是比较好的，可以复用在别的地方。

# 前端基础

## 什么是闭包,如何产生？除了返回函数

> 关于闭包面试题的坑：闭包与词法作用域密切相关，倘若答不上来两者之间的关系会被判定理解不足。另外，很多人对闭包存在误区，以为闭包就是那个特定的结构（返回的函数里有对外部变量的引用），但实则不然，这只是我们使用闭包的方法而已，不是闭包。

要说闭包，就要先说说JavaScript词法作用域了:

### JavaScript的词法作用域

#### 作用域：

作用域是指程序源码中定义的变量的访问规则————规定了如何查找变量，也就是确定了当前代码对变量的访问权限。

#### 词法作用域：

就是代码在编写过程就体现出来的作用范围。代码一旦写好，不用执行，作用范围就已经确定好了，这个就是所谓的词法作用域。

> 与之相对的是动态作用域，函数的作用域是在函数调用的时候才决定的

#### 作用域链：

> 当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

### 闭包

当代码执行的过程中会经过两个阶段——编译期和执行期

- 编译期：这个过程会进行词法分析语法分析，然后生成可执行代码

- 执行期：这个过程中会创建执行上下文，然后执行代码，最后垃圾回收

  创建执行上下文会做下面这些事：

  1. 创建内部变量对象
  2. 创建作用域链。
  3. 确定 this 指向。

  > 在创建作用域链的过程中，“闭包”就顺理成章的创建了，内部保存的就是对外部作用域中变量的引用。因此并不需要返回引用了外部变量的内部函数，闭包就已经创建了，但是返回之后，我们才可以拿到并使用。

一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。

### 闭包的应用

1. 在es6之前模仿块级作用域
2. 柯里化：把先前传入的参数用闭包保存起来
3. 创建一个私有空间，保护内部的变量
4. 缓存：如果函数调用处理耗时，我们可以将结果在内存中缓存起来，下次执行时，若存在内存中，则直接返回

面试官说了防抖节流：二者区别

- 防抖：用户连续操作后延迟执行回调
- 节流：连续触发某个事件，在一定时间内只执行一次

参考文章：[从编译原理的角度彻底理解什么是闭包(Closure)](https://juejin.cn/post/7055322482600837133)

## Promise解决了哪些痛点

避免了回调地狱

### 什么是**回调地狱**：

把"回调地狱"理解成大量的函数嵌套和大量的缩进似乎有欠妥当，因为我们大可以把这些代码抽离出来，这在我们写代码的过程中其实是一件很常见的事情。

“回调地狱”所说的嵌套其实是指**异步的嵌套**。它带来了两个问题：`可读性的问题`和`信任问题`

#### 可读性问题：

异步任务在阅读起来本来就比较吃力，因为这些任务有的是同步的，有的是异步的，我们需要随时想着这些任务的执行顺序，随着任务复杂度提高，代码阅读难度几何倍数增长。

#### 信任问题：

传统的回调函数可能会出现以下问题

- 回调函数被回调过早（一般是异步任务被同步调用）；
- 回调函数没有被调用或过晚被调用；
- 回调次数过多；

> 使用回调函数的方式，如果我们使用了第三方的库并传入了一个回调函数，回调的调用时机对我们来说都是透明的，这样很危险，这个第三方库对我们来说是不可信任的。我们给他提供的回调函数相当于一种依赖注入，发生了控制翻转，这在模块解耦中很有用，但是不应该用在这里。

### Promise的解决原理

#### **Promise解决可读性问题**

Promise一定是异步的，这样的话代码就会清晰很多。

#### **Promise解决信任问题**

实际上Promise也不是没有发生控制翻转，只是通过resolve和reject翻转了控制翻转，将控制权又交回给了程序员。在Promise中，回调只用于通知成功或者失败。

- **次数过多**：Promise的状态只能被改变一次，then方法的回调也只能执行一次，这就解决了回调次数的问题。
- **回调过早**：Promise一定是一个异步任务。
- **没有被调用**：Promise本身一定会调用，但是由于网络原因引起的回调过晚无法解决，但是可以用`Promise.race()`实现超时时间

参考文章：[Promise到底解决了什么问题？](https://juejin.cn/post/6844903636737196045) 、[听起来高大上的控制反转（IOC）是什么？](https://juejin.cn/post/7147877236022968334)

### Promise应用场景

Promise.all()：将多个请求合并在一起

Promise.race()：处理超时

Promise.then()：下一个请求依赖于上一个请求、处理中间数据

### awit后面跟一个同步函数会怎么样

会将后面的数据用`Promise.resolve()`包装一下，依然会阻塞后面的代码

## 事件循环：宏任务有哪些，微任务有哪些

单线程任务被分为同步任务和异步任务，在执行栈中，同步任务同步执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中，并且会根据任务的类型（宏任务，微任务）进入不同的任务队列

### 微任务（micro task）

> - promise
> - async
> - await
> - process.nextTick(node)
> - mutationObserver(html5新特性，用于监听dom树事件)

### 宏任务(macro task)

> - script(整体代码)
> - setTimeout、setInterval定时器
> - setImmediate
> - I/O
> - UI render

# Vue

## vue组件通信方式

- props
- emit
- v-model
- refs
- provide/inject
- eventBus全局事件总线，Vue3中是mitt，但是不推荐使用
- vuex/pinia(状态管理工具)

## vuex解决了哪些问题

组件间数据的共享

## 首屏加载慢（白屏）的原因，如何排查

### **产生原因：**

由于使用React和Vue打包出的js和css文件太大，加载需要一定的时间，而js没有执行之前是不会有dom元素的，因此就出现了视觉上的白屏

### 解决办法：

- **视觉效果：**在HTML里加一个loading动画，当页面加载完成后消失。
- **路由懒加载：**使用路由懒加载，将文件拆分，只有在访问到对应路由时才会加载。在移动端，可以只加载可视区域的内容，剩下的等它快要进入可视区的时候加载。
- **CDN资源优化：**如果项目依赖了很多第三方包，可以在index.html里插入相应的链接，将这些包用CDN连接获取。打包的时候就不打包这些资源了
- **缓存：**
  - 接口缓存：一些用于获取数据的get请求使用接口缓存
  - 静态数据缓存：长期不会更改的用强缓存，可能会更改的用ETag实现协商缓存。
- **终极办法——服务端渲染：**在服务端将渲染逻辑处理好，然后将处理好的HTML直接返回给前端展示，根本上解决白屏问题。
- **骨架屏：**使用骨架屏过度，在视觉上提高用户体验

# React

## ReactHooks原理

首先每个`hooks`都有两个阶段——第一次创建的时候的`mount`阶段，之后的每次都是`update`阶段。（这两个阶段都是函数）

在`mount`阶段中，会依照我们在函数组件中使用到的hooks按顺序创建一个个`hook`对象，用不同的`hooks函数`创建的`hook`对象之间是不同的，每个hook对象上都储存着自身所需要的数据（`hook.memorizedState`），不同`hook`对象有不同的使用数据的逻辑，最后会将这些hook对象按顺序连接起来，组成单向链表，并把第一个挂载在fiber上（`fiber.memorizedState`）。

至于`update`阶段，则会执行具体的更新逻辑，根据不同的逻辑创建 `effect` 对象，并将组件内的 `effect` 对象串成**环状单向链表**，放到`fiber.updateQueue`上面，等到`commit`阶段进行处理

在`update`阶段中，对比新旧状态是通过`hook`链表的对应顺序实现的，因此，不能以任何方式改变`hooks`顺序，否则拿不到匹配的`hook`就会报错。 

## Fiber

fiber 架构，实现异步可中断更新。先把 `vdom` 树转成 `fiber` 链表，然后再渲染 `fiber`。主要是解决之前由于直接递归遍历 `vdom`，不可中断，导致当 `vdom` 比较大的时候，频繁调用耗时 `dom api` 容易产生性能问题。fiber链表上有一系列指针属性，记录该`fiber`节点的父节点，子节点，兄弟节点等等。通过这些节点的调用优先级，可以模拟出递归深度优先遍历。这样，`fiber`就是一个可中断的结构，我们可以适时地让出`进程`，让浏览器去执行一些更重要的操作，比如处理用户的输入，防止用户感觉到卡顿。



# React和Vue

## React和Vue的区别

#### 写法不同：

react使用jsx，all in js，vue使用模板，all in vue，各有优势，现在vue也支持jsx了。

#### 设计理念不同：

react有个很明显的特点就是数据不可变，相对的，Vue则是数据可变的；因此在react中有很明显的函数式编程的特点，而Vue虽然引入了组合式API，但是在官方文档中也说了，尽管它是函数式编程的风格，但并不是函数式编程，因为它使用响应式数据，一定会引起副作用。

#### 响应式不同：

vue使用数据代理，自动处理；react需要手动设置；react推崇数据不可变、单向数据流，而Vue专攻上手简单和依赖收集。

#### 更新方式不同：

vue会自动追踪依赖关系，只更新必要的部分；react会自顶向下全部diff，需要手动用shouldComponentUpdate做逻辑判断。但是react有fiber可以很好的提高用户体验。

#### diff算法有所不同：

react因为其fiber结构是链表的原因，无法使用双端diff，但是vue是数组，使用双端diff效率较高。react对那种节点被后移的操作不敏感，会导致很多多余的dom操作。

## Hooks的优点，为什么使用Hooks

什么是hooks，译作钩子。

react中用use开头的一系列函数，使得函数组件能够使用state和effect

vue3中使用组合式API，提供了组件复用、状态管理等开发能力的方法。

为什么使用hooks：

1. 更好的状态复用

   - 在没有hooks的时候，react和vue都使用了mixin的解决方案，但是这种解决方案局限性很大
     - 首先混入的代码必须是我们已经知晓的，否则我们根本不能从代码中看出混入了什么
     - 其次实际上它的复用性很差，基本上同一个mixin只能使用一次
     - 命名空间重叠，不同mixin会导致命名冲突。
   - 而使用了hooks之后，就很轻松的解决了上述问题
     - 首先，我们用返回值中可以取到需要的变量和函数，这就意味着，hooks做了什么我们无需知道，但是我们可以知道它做到了什么
     - 同一个hooks可以多次使用，返回的变量的命名完全由主流程控制
     - 不同的hooks也不会命名冲突，因为hooks内部会形成一个闭包，内部的变量会被保护起来，是单独的命名空间。

2. 能够更好的组织代码

   在Vue和React没有使用Hooks之前，React的类组件和Vue的声明式编程都有一个问题，就是不同功能的逻辑被混在一起，因为必须要把数据放一块，方法放一块，生命周期钩子放一块。这就导致一个功能的代码被拆到各个地方，阅读起来很费劲

   但是有了hooks就可以把相关的所有代码写在一起，这样聚合度更高，可读性更好——所以效率更高，bug更少

3. 比class组件更容易理解

   因为是函数，不需要使用this，就不用考虑this指向的问题，我虽然一直用React的函数组件，但是之前学习的时候，看到那么多this就很头大。


# NodeJS

## cjs和ems，在编译上有什么区别

### CommonJS

- cjs是靠js运行时来实现的。
- 只导出一个属性——module，并且导入的时候导入的是值的拷贝。
- 动态加载，通过对每一个加载都存在缓存，有效的解决循环引用问题。
- 同步加载并执行模块。
- 默认非严格模式。

### ES Module

- 静态导入，不能放在块级作用域内，导入过程发生在编译时，因此很容易实现 Tree Shaking。
- 可以导出多个属性和方法，可以单个导入导出，混合导入导出。
- 模块提前加载并执行模块文件。并且导入的是值的引用，如果发生循环引用，引用了未被初始化的变量会报错。
- 使用顶层 await 设计。因此cjs可以使用import()引入，但是引入的方法还是拷贝。
- 默认严格模式。

参考文章：[「万字进阶」深入浅出 Commonjs 和 Es Module](https://juejin.cn/post/6994224541312483336#heading-28)

# `Webpack`

## Webpack配置过吗

脚手架直接配置好的，但是知道它的原理

首先用初始化参数初始化一个`Compiler`对象，调用它的`run`方法开始构建，从入口文件开始，生成`AST`抽象语法树，然后找到它的依赖，如果它的依赖不是`.js`文件，那么就要调用loader进行转换，**递归重复此步骤直到所有依赖的文件都被转化过**，这时候就有了一个依赖关系图谱。再将`AST`语法树转换成浏览器可识别的code，由于浏览器不支持`commenjs`语法规范，所以想要处理模块之间的依赖需要重写`require`函数，用这个函数**将所有依赖的文件整合到一个文件**中，也就是`bundle`，然后交给浏览器执行。

知道它的原理之后，再知道插件调用的时机和功能，就可以配置插件了

### 插件功能主要有几大类：

- 功能类：可以用于优化使用者体验和效率：比如删除原先打包好的文件、控制台输出优化之类、编译效率分析等等
- 代码相关类：自动加载文件、定义全局变量
- 编译结果优化类：混淆代码、拆分文件、压缩文件
- 编译优化：预编译、多线程编译、编译缓存

## `Webpack` 编译流程

1. **初始化参数**：从配置文件和`shell`语句中读取并合并参数，`shell`的优先级更高
2. **开始编译**：用初始化参数初始化`Compiler`（编译）对象，加载所有配置的插件，插件会订阅一些`webpack`的事件，而在合适的时机执行进行转换工作。然后执行对象的`run`方法执行编译。
3. **确定入口**：根据配置中的`entry`找出所有文件的入口。
4. **编译模块**：调用配置的所有`loader`对模块进行编译，再找出该模块所依赖的模块。递归执行本步骤，直到所有的依赖文件都被经过了本步处理
5. **输出资源**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的`Chunk`，再把每个`Chunk`转换成一个单独的文件加入到输出列表。
6. **输出完成**：确定好输出内容之后，根据配置确定输出内容的路径，把输出内容写入到文件系统中。

## `Webpack` 构建流程

首先用初始化参数初始化一个`Compiler`对象，调用它的`run`方法开始构建，从入口文件开始，生成`AST`抽象语法树，然后找到它的依赖，如果它的依赖不是`.js`文件，那么就要调用loader进行转换，**递归重复此步骤直到所有依赖的文件都被转化过**，这时候就有了一个依赖关系图谱。再将`AST`语法树转换成浏览器可识别的code，由于浏览器不支持`commenjs`语法规范，所以想要处理模块之间的依赖需要重写`require`函数，用这个函数**将所有依赖的文件整合到一个文件**中，也就是`bundle`，然后交给浏览器执行。

> （`vite`之所以快，就是因为它利用了浏览器对`esm`的支持）

## `Webpack` 热更新原理

1. 启动`webpack`，生成`compiler`实例。`compiler`上有很多方法，比如可以启动 `webpack` 所有**编译**工作，以及**监听**本地文件的变化。
2. 使用`express`框架启动本地`server`，让浏览器可以请求本地的**静态资源**。
3. 本地`server`启动之后，再去启动`websocket`服务。通过`websocket`可以建立本地服务和浏览器的双向通信。这样就可以实现当本地文件发生变化，告知浏览器可以热更新代码了。
4. 然后会在入口文件添加两个路径，这样对应的代码就会打包到`webpack`最终输出的`bundle`上去，这样就实现了代码的注入。这两段代码分别是**实现socket通信**和**检查更新**的
5. 监听`webpack`编译完成事件，回调函数中会通过`websocket`和浏览器通信，通知`hash`和`ok`事件，这样浏览器就拿到了最新的哈希值，用于检查更新
6. `webpack`会监听文件发生变化的事件，主要是通过**文件的生成时间**是否有变化实现，当文件发生变化，重新编译，编译完成之后继续监听
7. 浏览器的`websocket`在接收到`hash`和`ok`两个事件后，分别会进行**更新哈希值**和**热更新检查**。检查到需要更新后，就会向本地`server`发送`ajax`请求，通过最新的`hash`值作为参数，根据请求结果获得到热更新模块，以及下次热更新的`Hash` 标识。然后通过`JSONP`方式发送`xxx/hash.hot-update.js` 请求（因为返回的文件是一个函数，需要立即执行，他会把需要更新的模块放在一个全局变量上，在下一步中会用到）
8. `hotApply` 热更新模块替换
   1. 删除过期的模块，就是需要替换的模块
   2. 将新的模块添加到 `modules` 中
   3. 通过`__webpack_require__`执行相关模块的代码

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a4f10eb6de943b88f7a3313d8aa5795~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

# `Vite`的快和慢

## `Webpack`的慢

### 冷启动

`Webpack` 能大行其道，归功于它划时代的采用了 `bundle` 机制。通过这种 `bundle` 机制，`Webpack` 可以将项目中各种类型的源文件转化供浏览器识别的 `js`、`css`、`img` 等文件，建立源文件之间的依赖关系，并将数量庞大的源文件合并为少量的几个输出文件。

`bundle` 工作机制的核心部分分为两块：构建**模块依赖图** - `module graph` 和将 `module graph` 分解为最终供浏览器使用的几个输出文件。

强大的 `bundle` 机制，也引发了构建速度缓慢的问题，而且项目规模越大，构建速度越是缓慢。其主要原因是构建 `module graph` 的过程中，涉及到大量的文件 `IO`、文件 `transfrom`、文件 `parse` 操作；以及分解 `module graph` 的过程中，需要遍历 `module graph`、文件 `transform`、文件 `IO` 等。这些操作，往往需要消耗大量的时间，导致构建速度变得缓慢

### 热更新

当源文件发生变化后，`Webpack` 会重新编译打包。这个时候，由于我们只修改了一个文件，因此只需要对这个源文件做 `resolve`、 `load`、 `transfrom`、`parse` 操作，依赖的文件直接使用缓存，因此 `dev server` 的响应速度比冷启动要好很多。

`dev server` 重新编译打包以后，会通过 `websocket` 连接通知浏览器去获取新的打包文件，然后对页面做局部更新

## `vite`的快

### 冷启动

`Vite` 之所以在 `dev server` 启动方面，如此给力，是因为它采取了与 `Webpack` 截然不同的 `unbundle` 机制。

`unbundle` 机制，顾名思义，不需要做 `bundle` 操作，即不需要构建、分解 `module graph`，源文件之间的依赖关系完全通过浏览器对 `ESM` 规范的支持来解析。这就使得 `dev server` 在启动过程中只需做一些初始化的工作，剩下的完全由浏览器支持。

至于源文件的 `resolve`、`load`、`transform`、`parse` 等操作，浏览器发起请求以后，`dev server` 端会对请求做拦截，然后对源文件做 `resolve`、`load`、`transform`、`parse` 操作，然后再将转换以后的内容发送给浏览器。

简单概括就是

- 模块之间的依赖关系的解析由浏览器实现；
- 文件的转换由 `dev server` 的 `middlewares` 实现并做缓存；
- 不对源文件做合并捆绑操作；

### 热更新

由于 `Vite` 采用 `unbundle` 机制，所以 `dev server` 在监听到文件发生变化以后，只需要通过 `websocket` 连接通知浏览器去重新加载变化的文件，剩下的工作就交给浏览器去做了。

## `Webpack`的快

### 首屏加载时间

浏览器向 `dev server` 发起请求， `dev server` 接受到请求，然后将已经打包构建好的首屏内容发送给浏览器。文件数量比较少，因此加载更快

### 懒加载

由于所依赖的文件已经处理好，所以响应很快

## `vite`的慢

### 首屏加载时间

由于 `unbundle` 机制，首屏期间需要额外做以下工作:

- 不对源文件做合并捆绑操作，导致大量的 `http` 请求；
- `dev server` 运行期间对源文件做 `resolve`、`load`、`transform`、`parse` 操作；
- 预构建、二次预构建操作也会阻塞首屏请求，直到预构建完成为止；

和 `Webpack` 对比，`Vite` 把需要在 `dev server` 启动过程中完成的工作，转移到了 `dev server` 响应浏览器请求的过程中，不可避免的导致首屏性能下降。

不过首屏性能差只发生在 `dev server` 启动以后第一次加载页面时发生。之后再 `reload` 页面时，首屏性能会好很多。原因是 `dev server` 会将之前已经完成转换的内容缓存起来。

### 懒加载

和首屏一样，由于 `unbundle` 机制，动态加载的文件，需要做 `resolve`、`load`、`transform`、`parse` 操作，并且还有大量的 `http` 请求，导致懒加载性能也受到影响。

## 总结

和 `Webpack` 对比，`Vite` 把需要在 `dev server` 启动过程中完成的工作，转移到了 `dev server` 响应浏览器请求的过程中，与webpack相比，解决了一些痛点，同时也引入了一些新的问题，不过这些问题也可以通过别的方式进行解决，但总体来说开发体验提升很大。



# 浏览器相关

## 浏览器进程

#### 1、Browser进程

> 浏览器的主进程（负责协调、主控），只有一个，相当于浏览器的大脑，作用有：
>
> 负责浏览器界面显示，与用户交互，如前进，后退等；
>
> 负责各个页面的管理，创建和销毁其他进程；
>
> 将渲染线程得到的内存中的位图渲染到用户界面上；
>
> 网络资源的管理，下载等。

#### 2、插件进程

> 因为插件易崩溃，所以通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
>  每种类型的插件对应一个进程，仅当使用该插件时才创建。

#### 3、GPU进程

> 也只有一个，用于3D绘制，只有当该页面使用了硬件加速才会使用它，来渲染页面。
>
> 否则的话，不使用这个进程，而是用Browser进程来渲染页面。

#### 4、渲染进程 （前端重点）

> 每一个tab页面都有一个渲染进程，而且互相之间是不影响的，主要用来渲染页面，进行脚本执行等。在这个进程中，还有1、界面渲染线程，2、js引擎线程，3、浏览器事件处理线程等，4、http请求线程

#### 5、网络进程

> 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立处理，成为单独一个进程。



作者：小撕夜
链接：https://juejin.cn/post/7146410097281859591
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 计算机网络

## 网络OSI七层模型

![alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/28/16fec363208256b8~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

## 什么是HTTP？该如何表述

超文本传输协议，顾名思义就是用来传输超文本（也就是文字、图片、音视频以及其他多媒体文件）的一套规范。

**请求报文：**起始行 + 头部 + 空行 + 实体

### 起始行

##### `请求报文`的起始行

```http
GET /home HTTP/1.1
```

也就是**方法 + 路径 + http版本**。

##### `响应报文`的起始行

```http
HTTP/1.1 200 OK
```

响应报文的起始行也叫做`状态行`。由**http版本、状态码和原因**三部分组成。

> HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个":"前缀，用来和其它请求头区分开。

### 头部

不管是请求头还是响应头，都有相当多的头部字段，用于传达信息

## HTTP 缺点

### 无状态

所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的**无状态**。

在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。

但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

在`Http1.1`开始，默认长链接

### 明文传输

即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。

这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。`WIFI陷阱`就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。

> HTTP2.0开始就使用二进制格式了

### 队头阻塞问题

当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的**队头阻塞**问题。

> **`HTTP1.1`解决队头阻塞：**对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务，但是浏览器对一个域名能发起的长链接的数量有限，于是又出现了域名分片————一个域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了。这是一种治标不治本的方法
>
> **`HTTP2.0`解决队头阻塞：**原来`Headers + Body`的报文格式如今被拆分成了一个个二进制的帧，用**Headers帧**存放头部字段，**Data帧**存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。(没太看懂)
> 参考文章：[（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系](https://juejin.cn/post/6844904100035821575)

## TCP三次握手四次挥手

### 三次握手

**第一次握手：**客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。

**第二次握手：**服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。

**第三次握手：**客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

### 四次挥手

**第一次挥手：** 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。

**第二次挥手**：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。

**第三次挥手**：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。

**第四次挥手：** 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

## HTTP常见请求/响应头

用于缓存的：`If-Modified-Since`、`If-Match`、`If-None-Match`、`Cache-Control`、`ETag`、`Expires`、`Last-Modified`

用于提供信息的：`Host`、`User-Agent`、`Accept`、`Transfer-Encoding`、`Allow`

用于断点续传的：`Range`、`If-Match`

用于控制连接的：`Connection`、`Location`

## cookies、session、token

HTTP 协议是一种`无状态协议`，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。

### cookie

**是什么：**cookie是服务器发送到Web浏览器的一小块数据。浏览器得到发送过来的cookie后会进行存储，以后发送请求会携带上cookie。通常它被用来判断两个请求是否来自同一个浏览器，例如`保持用户登录状态`或者个性化设置。

**分类：**如果没有设置到期时间就会视为`会话cookie`，如果设置了就是`永久cookie`，直到过期

**HttpOnly的作用：**可以禁止Cookie被客户端脚本访问到，防止Cookie被窃取

**作用域：**指定了Domin一般包含子域名，没有指定则只有当前主机。Path也会匹配子路由

### session

**是什么：**客户端请求服务端，服务端就会为这次请求开辟一块内存空间，存储一个`Session`对象，作用就是储存客户端在同一个会话中的操作记录。

**Session的工作方式：**客户端第一次请求服务端，服务端就会为这次请求开辟一块Session空间，并生成一个sessionId，返回客户端并将sessionId存为`会话cookie`，这样以后发送请求就会带上这个cookie，服务端读取到这条信息后就能找到对应的Session对象。

**缺点：**数据存储在特定服务器，如果做了负载均衡，请求被转发到别的服务器，这个session就没用了。

### JSON Web Tooken

Json Web Token 的简称就是 JWT，通常可以称为 `Json 令牌`。它是用于`安全的`将信息作为 `Json 对象`进行传输的一种形式。JWT 中存储的信息是经过`数字签名`的，因此可以被信任和理解。



JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。

 ```json
 {
 "姓名": "张三",
 "角色": "管理员",
 "到期时间": "2018年7月1日0点0分"
 }
 ```

服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。

JWT分为三个部分，Header（保存JWT元信息）、Payload（保存实际要传递的数据）、Signature（签名），前两个是用base64表示的json对象。

1. JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
2. JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
3. JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
4. 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。

# 操作系统

## 进程与线程

#### 进程

进程`Process`是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。

#### 线程

线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。**一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的**。



# 浏览器

### V8垃圾回收机制

内存空间氛围新生代和老生代，使用不同的算法

新生代：这部分的回收比较频繁，使用`Scavenge`算法，对象一开始进入这个区域，新生代内存被分为两个空间，叫做From和To，From存储数据To为闲置状态，开始垃圾回收时，会先会检查From空间中存活的对象，将所有存活对象复制到To空间中，剩下的就是非存活的变量，直接清空，然后调换两个空间的角色等待下一次回收。

对象晋升，当新生代内存不足时，就会把一部分存活时间比较久的对象复制到老生代，以下是两个条件

- 对象是否经历过一次`Scavenge`算法
- `To空间`的内存占比是否已经超过`25%`

老生代：这部分空间较小，回收也没有那么频繁，使用的算法也不同，是通过 `Mark-Sweep（标记清除）`和 `Mark-Compact（标记整理）`两个算法实现的，前一个就是从根对象开始遍历，删掉无法遍历到的对象的那个算法，但是由于这样做会产生内存碎片，所以又用标记整理来清除碎片，就是把所有存活的对象移到一端，然后剩下的空间直接清除

参考文章：[V8引擎垃圾回收原理解析](https://juejin.cn/post/6969875260472557582#heading-6)

# 前端安全

## 什么是CSRF攻击

> **CSRF即Cross-site request forgery(跨站请求伪造)**，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。

假如黑客在自己的站点上放置了其他网站的外链，例如`"www.weibo.com/api`，默认情况下，浏览器会带着`weibo.com`的cookie访问这个网址，如果用户已登录过该网站且网站没有对CSRF攻击进行防御，那么服务器就会认为是用户本人在调用此接口并执行相关操作，致使账号被劫持。

## 如何防御CSRF攻击

- 验证`Token`：浏览器请求服务器时，服务器返回一个token，每个请求都需要同时带上token和cookie才会被认为是合法请求
- 验证`Referer`：通过验证请求头的Referer来验证来源站点，但请求头很容易伪造
- 设置`SameSite`：设置cookie的SameSite，可以让cookie不随跨域请求发出，但浏览器兼容不一

## 什么是XSS攻击

> **XSS即Cross Site Scripting（跨站脚本）**，指的是通过利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入JS代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取

## XSS攻击有哪些类型

- **存储型**：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击。
- **反射型**：攻击者将脚本混在URL里，服务端接收到URL将恶意代码当做参数取出并拼接在HTML里返回，浏览器解析此HTML后即执行恶意代码
- **DOM型**：将攻击脚本写在URL中，诱导用户点击该URL，如果URL被解析，那么攻击脚本就会被运行。和前两者的差别主要在于DOM型攻击不经过服务端

## 如何防御XSS攻击

- **输入检查**：对输入内容中的`<script><iframe>`等标签进行转义或者过滤
- **设置httpOnly**：很多XSS攻击目标都是窃取用户cookie伪造身份认证，设置此属性可防止JS获取cookie
- **开启CSP**，即开启白名单，可阻止白名单以外的资源加载和运行

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ff9939df9d71~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

# git

## 平时git是如何使用的

**实习的时候常用的命令比较基本：**主要是拉取（pull）、推送（push）、提交（commit）、还有分支（branch）、合并（merge）这些操作；

**主要流程：**一般是一个功能创建一个分支，合并到主分支用拉取请求，如果出现冲突的话，就会把最新的代码重新拉取下来，在本地处理完冲突之后再重新提交。

**优化提交记录：**但是这种提交方法虽然有效便捷，但是会让提交记录很难看，再加上我当时的提交经常会有需要改动的地方，所以总是会多出很多没用的记录，后来mentor就让我用 rebase 变基合并我自己分支的提交记录，然后提pr的时候也 rebase 到最新的节点上。

**工作需要：**有时候我自己拉了一个分支写新功能，然后突然让我去修一个bug，这个时候我以前会先把自己手上的代码提交一次，然后切出去做别的工作，后来学了一个新技巧，用 stash 保存自己的修改，这样就不会产生奇怪的记录了。











